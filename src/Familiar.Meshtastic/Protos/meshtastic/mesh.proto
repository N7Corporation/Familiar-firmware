syntax = "proto3";

package meshtastic;

option csharp_namespace = "Meshtastic.Protobufs";

import "meshtastic/portnums.proto";
import "meshtastic/telemetry.proto";
import "meshtastic/channel.proto";
import "meshtastic/config.proto";

// Hardware model identifiers
enum HardwareModel {
  // Unset/unknown
  HW_UNSET = 0;

  // TLoRa V2.1-1.6 (ESP32 + SX1276)
  TLORA_V2_1_1P6 = 1;

  // TLoRa V2 (ESP32 + SX1276)
  TLORA_V2 = 2;

  // TLoRa V1 (ESP32 + SX1276)
  TLORA_V1 = 3;

  // TBeam (ESP32 + SX1262)
  TBEAM = 4;

  // Heltec V2.0 (ESP32 + SX1276)
  HELTEC_V2_0 = 5;

  // Heltec V2.1 (ESP32 + SX1262)
  HELTEC_V2_1 = 6;

  // T-Echo (nRF52840 + SX1262)
  TECHO = 8;

  // RAK4631 (nRF52840 + SX1262)
  RAK4631 = 25;

  // RAK11200 (ESP32 + SX1262)
  RAK11200 = 26;

  // Nordic nRF52840 DK
  NRF52840DK = 32;

  // Heltec V3 (ESP32-S3 + SX1262)
  HELTEC_V3 = 43;

  // Station G1 (ESP32 + SX1262)
  STATION_G1 = 44;

  // Generic ESP32
  ESP32_S3_PICO = 65;

  // Private HW
  PRIVATE_HW = 255;
}

// Priorities for mesh packets
enum MeshPacketPriority {
  // Unset
  PRIORITY_UNSET = 0;

  // Min priority
  PRIORITY_MIN = 1;

  // Background priority
  PRIORITY_BACKGROUND = 10;

  // Default priority
  PRIORITY_DEFAULT = 64;

  // Reliable priority (for acks, routing)
  PRIORITY_RELIABLE = 70;

  // ACK priority
  PRIORITY_ACK = 120;

  // Max priority
  PRIORITY_MAX = 127;
}

// Position data
message Position {
  // Latitude in degrees * 1e-7
  sfixed32 latitude_i = 1;

  // Longitude in degrees * 1e-7
  sfixed32 longitude_i = 2;

  // Altitude in meters above MSL
  int32 altitude = 3;

  // Unix timestamp when position was taken
  fixed32 time = 4;

  // Source of position data
  PositionSource location_source = 5;

  // Altitude source
  PositionSource altitude_source = 6;

  // Timestamp source
  fixed32 timestamp = 7;

  // Timestamp milliseconds
  int32 timestamp_millis_adjust = 8;

  // Altitude HAE
  sint32 altitude_hae = 9;

  // Altitude geoidal separation
  sint32 altitude_geoidal_separation = 10;

  // PDOP
  uint32 PDOP = 11;

  // HDOP
  uint32 HDOP = 12;

  // VDOP
  uint32 VDOP = 13;

  // GPS accuracy in mm
  uint32 gps_accuracy = 14;

  // Ground speed in m/s * 100
  uint32 ground_speed = 15;

  // Ground track in degrees * 1e-5
  uint32 ground_track = 16;

  // Fix quality
  uint32 fix_quality = 17;

  // Fix type
  uint32 fix_type = 18;

  // Satellites in view
  uint32 sats_in_view = 19;

  // Sensor ID
  uint32 sensor_id = 20;

  // Next update timestamp
  uint32 next_update = 21;

  // Sequence number
  uint32 seq_number = 22;

  // Precision bits
  uint32 precision_bits = 23;

  enum PositionSource {
    // Unknown/not set
    LOC_UNSET = 0;
    // Manual
    LOC_MANUAL = 1;
    // Internal GPS
    LOC_INTERNAL = 2;
    // External GPS
    LOC_EXTERNAL = 3;
  }
}

// User information
message User {
  // User ID (node number as hex string with ! prefix)
  string id = 1;

  // Long name (human readable)
  string long_name = 2;

  // Short name (4 chars max)
  string short_name = 3;

  // MAC address (optional)
  bytes macaddr = 4;

  // Hardware model
  HardwareModel hw_model = 5;

  // Is licensed
  bool is_licensed = 6;

  // Role
  Config.DeviceConfig.Role role = 7;

  // Public key for PKC
  bytes public_key = 8;
}

// Routing error codes
enum Routing_Error {
  // No error
  NONE = 0;
  // No route to destination
  NO_ROUTE = 1;
  // Got NAK from destination
  GOT_NAK = 2;
  // Timeout waiting for response
  TIMEOUT = 3;
  // No interface
  NO_INTERFACE = 4;
  // Max retransmit exceeded
  MAX_RETRANSMIT = 5;
  // No channel
  NO_CHANNEL = 6;
  // Too large
  TOO_LARGE = 7;
  // No response
  NO_RESPONSE = 8;
  // Duty cycle limit
  DUTY_CYCLE_LIMIT = 9;
  // Bad request
  BAD_REQUEST = 32;
  // Not authorized
  NOT_AUTHORIZED = 33;
  // PKI failed
  PKI_FAILED = 34;
  // PKI unknown pubkey
  PKI_UNKNOWN_PUBKEY = 35;
  // Admin bad session key
  ADMIN_BAD_SESSION_KEY = 36;
  // Admin public key unauthorized
  ADMIN_PUBLIC_KEY_UNAUTHORIZED = 37;
}

// Routing information
message Routing {
  oneof variant {
    // Route request
    RouteDiscovery route_request = 1;

    // Route reply
    RouteDiscovery route_reply = 2;

    // Error reason
    Routing_Error error_reason = 3;
  }
}

// Route discovery
message RouteDiscovery {
  // Route taken so far
  repeated fixed32 route = 1;

  // SNR values for route
  repeated int32 snr_towards = 2;

  // Route back
  repeated fixed32 route_back = 3;

  // SNR towards dest
  repeated int32 snr_back = 4;
}

// Data payload
message Data {
  // Port number
  PortNum portnum = 1;

  // Payload bytes
  bytes payload = 2;

  // Want response
  bool want_response = 3;

  // Destination node (for PKI)
  fixed32 dest = 4;

  // Source node (for PKI)
  fixed32 source = 5;

  // Request ID (for response matching)
  fixed32 request_id = 6;

  // Reply ID (matches request)
  fixed32 reply_id = 7;

  // Emoji (for reactions)
  fixed32 emoji = 8;

  // Bitfield for PKI operations
  uint32 bitfield = 9;
}

// MeshPacket is the main packet used for mesh communication
message MeshPacket {
  // Source node number
  fixed32 from = 1;

  // Destination node number (0xFFFFFFFF = broadcast)
  fixed32 to = 2;

  // Channel index
  uint32 channel = 3;

  oneof payload_variant {
    // Decoded data
    Data decoded = 4;

    // Encrypted data
    bytes encrypted = 5;
  }

  // Unique packet ID
  fixed32 id = 6;

  // Receive timestamp (seconds since 1970)
  fixed32 rx_time = 7;

  // Receive SNR
  float rx_snr = 8;

  // Hop limit (decremented with each hop)
  uint32 hop_limit = 9;

  // Want ack
  bool want_ack = 10;

  // Priority
  MeshPacketPriority priority = 11;

  // Receive RSSI
  int32 rx_rssi = 12;

  // Hop start (original hop limit)
  uint32 hop_start = 15;

  // Delayed packet (stored in queue)
  bool delayed = 13;

  // Via MQTT
  bool via_mqtt = 14;

  // Public key for PKI
  bytes public_key = 16;

  // PKI encrypted
  bool pki_encrypted = 17;
}

// Information about a node on the mesh
message NodeInfo {
  // Node number
  fixed32 num = 1;

  // User info
  User user = 2;

  // Position
  Position position = 3;

  // SNR of last received packet
  float snr = 4;

  // Seconds since last heard
  fixed32 last_heard = 5;

  // Device metrics
  DeviceMetrics device_metrics = 6;

  // Channel for this node
  uint32 channel = 7;

  // Is via MQTT
  bool via_mqtt = 8;

  // Hops away
  uint32 hops_away = 9;

  // Is favorite
  bool is_favorite = 10;
}

// My node info
message MyNodeInfo {
  // My node number
  fixed32 my_node_num = 1;

  // Reboot count
  uint32 reboot_count = 8;

  // Min app version
  uint32 min_app_version = 11;
}

// Log record
message LogRecord {
  // Message
  string message = 1;

  // Timestamp
  fixed32 time = 2;

  // Source
  string source = 3;

  // Level
  Level level = 4;

  enum Level {
    // Unset
    UNSET = 0;
    // Critical
    CRITICAL = 50;
    // Error
    ERROR = 40;
    // Warning
    WARNING = 30;
    // Info
    INFO = 20;
    // Debug
    DEBUG = 10;
    // Trace
    TRACE = 5;
  }
}

// Queue status
message QueueStatus {
  // Res
  int32 res = 1;

  // Free
  uint32 free = 2;

  // Max length
  uint32 maxlen = 3;

  // Mesh packet ID
  uint32 mesh_packet_id = 4;
}

// ToRadio - message to send to the device
message ToRadio {
  oneof payload_variant {
    // Send a MeshPacket
    MeshPacket packet = 1;

    // Request config/nodedb
    uint32 want_config_id = 3;

    // Disconnect (BLE only)
    bool disconnect = 4;

    // XModem packet
    bytes xmodemPacket = 5;

    // MQTT client proxy message
    MqttClientProxyMessage mqttClientProxyMessage = 6;

    // Heartbeat
    Heartbeat heartbeat = 7;
  }
}

// Heartbeat message
message Heartbeat {
}

// MQTT client proxy message
message MqttClientProxyMessage {
  // Topic
  string topic = 1;

  oneof payload_variant {
    // Data
    bytes data = 2;

    // Text
    string text = 3;
  }

  // Retained
  bool retained = 4;
}

// Compressed message (for text messages)
message Compressed {
  // Port number
  PortNum portnum = 1;

  // Compressed data
  bytes data = 2;
}

// Neighbor info
message NeighborInfo {
  // Node number
  fixed32 node_id = 1;

  // Last sent by ID
  fixed32 last_sent_by_id = 2;

  // Node broadcast interval seconds
  uint32 node_broadcast_interval_secs = 3;

  // Neighbors
  repeated Neighbor neighbors = 4;
}

// Neighbor
message Neighbor {
  // Node ID
  fixed32 node_id = 1;

  // SNR
  float snr = 2;

  // Last RX time
  fixed32 last_rx_time = 3;

  // Node broadcast interval seconds
  uint32 node_broadcast_interval_secs = 4;
}

// Device metadata
message DeviceMetadata {
  // Firmware version
  string firmware_version = 1;

  // Device state version
  uint32 device_state_version = 2;

  // Can shutdown
  bool canShutdown = 3;

  // Has WiFi
  bool hasWifi = 4;

  // Has Bluetooth
  bool hasBluetooth = 5;

  // Has Ethernet
  bool hasEthernet = 6;

  // Role
  Config.DeviceConfig.Role role = 7;

  // Position flags
  uint32 position_flags = 8;

  // Hardware model
  HardwareModel hw_model = 9;

  // Has remote hardware
  bool hasRemoteHardware = 10;
}

// FileInfo for firmware updates
message FileInfo {
  // File name
  string file_name = 1;

  // Size in bytes
  uint32 size_bytes = 2;
}

// FromRadio - message received from the device
message FromRadio {
  // Packet ID
  uint32 id = 1;

  oneof payload_variant {
    // Received mesh packet
    MeshPacket packet = 2;

    // My node info
    MyNodeInfo my_info = 3;

    // Node info from database
    NodeInfo node_info = 4;

    // Config
    Config config = 5;

    // Log record
    LogRecord log_record = 6;

    // Config complete ID (matches want_config_id)
    uint32 config_complete_id = 7;

    // Reboot requested
    bool rebooted = 8;

    // Module config
    ModuleConfig moduleConfig = 9;

    // Channel
    Channel channel = 10;

    // Queue status
    QueueStatus queueStatus = 11;

    // XModem packet
    bytes xmodemPacket = 12;

    // Device metadata
    DeviceMetadata metadata = 13;

    // MQTT client proxy message
    MqttClientProxyMessage mqttClientProxyMessage = 14;

    // File info
    FileInfo fileInfo = 15;

    // Client notification
    ClientNotification clientNotification = 16;
  }
}

// Client notification
message ClientNotification {
  // Reply ID
  uint32 reply_id = 1;

  // Time
  fixed32 time = 2;

  // Level
  LogRecord.Level level = 3;

  // Message
  string message = 4;
}

// Device state (used internally by device)
message DeviceState {
  // My node info
  MyNodeInfo my_node = 2;

  // Owner info
  User owner = 3;

  // Node database
  repeated NodeInfo node_db = 4;

  // Receive queue
  repeated MeshPacket receive_queue = 5;

  // Version
  uint32 version = 8;

  // Rx text message
  MeshPacket rx_text_message = 7;

  // No save flag
  bool no_save = 9;

  // Did GPS reset
  bool did_gps_reset = 11;

  // Rx waypoint
  MeshPacket rx_waypoint = 12;

  // Node remote hardware pins
  repeated NodeRemoteHardwarePin node_remote_hardware_pins = 13;
}

// Node remote hardware pins
message NodeRemoteHardwarePin {
  // Node number
  fixed32 node_num = 1;

  // Pin
  ModuleConfig.RemoteHardwarePin pin = 2;
}

// Waypoint
message Waypoint {
  // Waypoint ID
  uint32 id = 1;

  // Latitude
  sfixed32 latitude_i = 2;

  // Longitude
  sfixed32 longitude_i = 3;

  // Expire timestamp
  fixed32 expire = 4;

  // Locked by
  fixed32 locked_to = 5;

  // Name
  string name = 6;

  // Description
  string description = 7;

  // Icon
  fixed32 icon = 8;
}
